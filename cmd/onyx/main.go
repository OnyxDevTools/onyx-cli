package main

import (
	"bytes"
	"encoding/json"
	"fmt"
	"os"
	"path/filepath"
	"strings"

	"github.com/spf13/cobra"

	onyxver "github.com/OnyxDevTools/onyx-cli/cmd/onyx/cmd"
	"github.com/OnyxDevTools/onyx-cli/internal/api"
	"github.com/OnyxDevTools/onyx-cli/internal/codegen"
	"github.com/OnyxDevTools/onyx-cli/internal/config"
	"github.com/OnyxDevTools/onyx-cli/internal/schema"
)

// Production onyx CLI entrypoint (distributed binary).
// Supports: info, init, gen, schema (get/validate/diff/publish).

func main() {
	if err := newRootCmd().Execute(); err != nil {
		fmt.Fprintln(os.Stderr, err)
		os.Exit(1)
	}
}

func newRootCmd() *cobra.Command {
	var cfgFlags cfgOptions

	cmd := &cobra.Command{
		Use:   "onyx",
		Short: "Onyx CLI",
	}

	// persistent config flags
	cmd.PersistentFlags().StringVar(&cfgFlags.DatabaseID, "database-id", "", "Onyx database ID")
	cmd.PersistentFlags().StringVar(&cfgFlags.BaseURL, "base-url", "", "Onyx base URL (schema API)")
	cmd.PersistentFlags().StringVar(&cfgFlags.APIKey, "api-key", "", "Onyx API key")
	cmd.PersistentFlags().StringVar(&cfgFlags.APISecret, "api-secret", "", "Onyx API secret")
	cmd.PersistentFlags().StringVar(&cfgFlags.AIBaseURL, "ai-base-url", "", "Onyx AI base URL")
	cmd.PersistentFlags().StringVar(&cfgFlags.DefaultModel, "default-model", "", "Default model name")
	cmd.PersistentFlags().StringVar(&cfgFlags.ConfigPath, "config", "", "Path to onyx config file (overrides search chain)")

	cmd.AddCommand(newInfoCmd(&cfgFlags))
	cmd.AddCommand(newInitCmd())
	cmd.AddCommand(newGenCmd(&cfgFlags))
	cmd.AddCommand(newSchemaCmd(&cfgFlags))
	cmd.AddCommand(newVersionCmd())

	return cmd
}

type cfgOptions struct {
	DatabaseID   string
	BaseURL      string
	APIKey       string
	APISecret    string
	AIBaseURL    string
	DefaultModel string
	ConfigPath   string
}

func resolveCfg(opts *cfgOptions) (config.ResolvedConfig, error) {
	return config.Resolve(config.Options{
		DatabaseID:   opts.DatabaseID,
		BaseURL:      opts.BaseURL,
		APIKey:       opts.APIKey,
		APISecret:    opts.APISecret,
		AIBaseURL:    opts.AIBaseURL,
		DefaultModel: opts.DefaultModel,
		ConfigPath:   opts.ConfigPath,
	})
}

func resolveCfgOrGuide(opts *cfgOptions) (config.ResolvedConfig, error) {
	rc, err := resolveCfg(opts)
	if err != nil {
		return rc, err
	}
	if err := rc.Validate(); err != nil {
		return rc, fmt.Errorf(
			"Onyx credentials not found (%v).\n\nTo fix:\n  1) Visit https://cloud.onyx.dev > Database > Manage Database > API Keys and create an API key.\n  2) Either download the onyx-database.json config file into your project (or point ONYX_CONFIG_PATH to it),\n     or set these environment variables:\n       - ONYX_DATABASE_ID\n       - ONYX_DATABASE_BASE_URL\n       - ONYX_DATABASE_API_KEY\n       - ONYX_DATABASE_API_SECRET\n",
			err,
		)
	}
	return rc, nil
}

// INFO ---------------------------------------------------------------------
func newInfoCmd(cfg *cfgOptions) *cobra.Command {
	return &cobra.Command{
		Use:   "info",
		Short: "Show resolved configuration",
		RunE: func(cmd *cobra.Command, args []string) error {
			resolved, err := resolveCfg(cfg)
			if err != nil {
				return err
			}
			printResolvedConfig(cmd, resolved)
			return nil
		},
	}
}

func printResolvedConfig(cmd *cobra.Command, rc config.ResolvedConfig) {
	out := cmd.OutOrStdout()
	fmt.Fprintf(out, "databaseId:   %s (source: %s)\n", rc.DatabaseID.Value, rc.DatabaseID.Source)
	fmt.Fprintf(out, "baseUrl:      %s (source: %s)\n", rc.BaseURL.Value, rc.BaseURL.Source)
	fmt.Fprintf(out, "apiKey:       %s (source: %s)\n", rc.APIKey.Value, rc.APIKey.Source)
	fmt.Fprintf(out, "apiSecret:    %s (source: %s)\n", config.MaskSecret(rc.APISecret.Value), rc.APISecret.Source)
	fmt.Fprintf(out, "aiBaseUrl:    %s (source: %s)\n", rc.AIBaseURL.Value, rc.AIBaseURL.Source)
	fmt.Fprintf(out, "defaultModel: %s (source: %s)\n", rc.DefaultModel.Value, rc.DefaultModel.Source)
	fmt.Fprintf(out, "codegenLang:  %s (source: %s)\n", rc.CodegenLang.Value, rc.CodegenLang.Source)
	if rc.ConfigFile != "" {
		fmt.Fprintf(out, "configFile:   %s\n", rc.ConfigFile)
	}
}

// INIT ---------------------------------------------------------------------
func newInitCmd() *cobra.Command {
	var schemaPath string
	var outDir string
	var pkg string
	var force bool

	cmd := &cobra.Command{
		Use:   "init",
		Short: "Create go:generate anchor for Go codegen",
		RunE: func(cmd *cobra.Command, args []string) error {
			if schemaPath == "" {
				schemaPath = "./api/onyx.schema.json"
			}
			if outDir == "" {
				outDir = "./gen/onyx"
			}
			if pkg == "" {
				pkg = "onyx"
			}
			content := fmt.Sprintf("//go:generate onyx gen --go --source file --schema %s --out %s --package %s\n\npackage tools\n\n// Generated by onyx init\n", schemaPath, outDir, pkg)
			if _, err := os.Stat("generate.go"); err == nil && !force {
				return fmt.Errorf("generate.go already exists (use --force to overwrite)")
			}
			if err := os.WriteFile("generate.go", []byte(content), 0o644); err != nil {
				return fmt.Errorf("write generate.go: %w", err)
			}
			fmt.Fprintln(cmd.OutOrStdout(), "Wrote generate.go")
			return nil
		},
	}
	cmd.Flags().StringVar(&schemaPath, "schema", "./api/onyx.schema.json", "Schema file path to embed in go:generate")
	cmd.Flags().StringVar(&outDir, "out", "./gen/onyx", "Output directory for generated Go client")
	cmd.Flags().StringVar(&pkg, "package", "onyx", "Go package name for generated client")
	cmd.Flags().BoolVar(&force, "force", false, "Overwrite existing generate.go")
	return cmd
}

// GEN ----------------------------------------------------------------------
func newGenCmd(cfg *cfgOptions) *cobra.Command {
	var schemaPath string
	var out string
	var pkg string
	var typeName string
	var pointerFields bool
	var langGo, langTS, langPy, langJava, langKt bool

	cmd := &cobra.Command{
		Use:   "gen",
		Short: "Generate client code from schema",
		RunE: func(cmd *cobra.Command, args []string) error {
			if _, err := resolveCfgOrGuide(cfg); err != nil {
				return err
			}

			selectedSchema := schemaPath
			if selectedSchema == "" {
				selectedSchema = config.DefaultSchemaPath
			}

			data, err := os.ReadFile(selectedSchema)
			if err != nil && os.IsNotExist(err) {
				if !cmd.Flags().Changed("schema") {
					alt := filepath.Join("api", config.DefaultSchemaPath)
					if altData, altErr := os.ReadFile(alt); altErr == nil {
						selectedSchema = alt
						data = altData
						err = nil
					} else {
						err = altErr
					}
				}
			}
			if err != nil {
				return fmt.Errorf("read schema: %w", err)
			}

			// choose language
			if !langGo && !langTS && !langPy && !langJava && !langKt {
				langTS = true // default for production binary
			}
			var generated []string

			if langGo {
				if out == "" {
					out = "./gen/onyx"
				}
				if pkg == "" {
					pkg = "onyx"
				}
				if err := codegen.RenderGoCommon(data, out, pkg, true, pointerFields); err != nil {
					return err
				}
				if err := codegen.RenderGoTables(data, out, pkg, true, pointerFields); err != nil {
					return err
				}
				generated = append(generated, fmt.Sprintf("Go client -> %s (package %s)", out, pkg))
			}
			if langTS {
				if out == "" {
					out = "./onyx/types.ts"
				}
				if typeName == "" {
					typeName = "OnyxSchema"
				}
				ts, err := codegen.RenderTypescriptTypes(data, typeName)
				if err != nil {
					return err
				}
				path := out
				if strings.HasSuffix(path, "/") || strings.HasSuffix(path, string(os.PathSeparator)) {
					if err := os.MkdirAll(path, 0o755); err != nil {
						return err
					}
					path = filepath.Join(path, "types.ts")
				} else {
					dir := filepath.Dir(path)
					if err := os.MkdirAll(dir, 0o755); err != nil {
						return err
					}
				}
				if err := os.WriteFile(path, []byte(ts), 0o644); err != nil {
					return err
				}
				generated = append(generated, fmt.Sprintf("TypeScript types -> %s", path))
			}
			if langPy {
				if out == "" {
					out = "./onyx"
				}
				if err := codegen.RenderPython(data, out, true); err != nil {
					return err
				}
				generated = append(generated, fmt.Sprintf("Python client -> %s", out))
			}
			if langJava {
				if out == "" {
					out = "./java"
				}
				if pkg == "" {
					pkg = "onyx"
				}
				if err := codegen.RenderJavaTypes(data, pkg, out, true); err != nil {
					return err
				}
				generated = append(generated, fmt.Sprintf("Java classes -> %s (package %s)", out, pkg))
			}
			if langKt {
				if out == "" {
					out = "./kotlin"
				}
				if pkg == "" {
					pkg = "onyx"
				}
				kt, err := codegen.RenderKotlinTypes(data, pkg)
				if err != nil {
					return err
				}
				if err := os.MkdirAll(out, 0o755); err != nil {
					return err
				}
				path := filepath.Join(out, "Onyx.kt")
				if err := os.WriteFile(path, []byte(kt), 0o644); err != nil {
					return err
				}
				generated = append(generated, fmt.Sprintf("Kotlin data classes -> %s", path))
			}

			if len(generated) == 0 {
				fmt.Fprintln(cmd.OutOrStdout(), "No code generated (select a language).")
			} else {
				for _, line := range generated {
					fmt.Fprintln(cmd.OutOrStdout(), line)
				}
			}
			return nil
		},
	}

	cmd.Flags().StringVar(&schemaPath, "schema", config.DefaultSchemaPath, "Schema file path")
	cmd.Flags().StringVar(&out, "out", "", "Output path (language-specific default if empty)")
	cmd.Flags().StringVar(&pkg, "package", "", "Go/Java/Kotlin package name")
	cmd.Flags().StringVar(&typeName, "name", "", "TypeScript export type name (default OnyxSchema)")
	cmd.Flags().BoolVar(&pointerFields, "go-pointer-fields", false, "Generate Go struct fields as pointers when nullable")
	cmd.Flags().BoolVar(&langGo, "go", false, "Generate Go client")
	cmd.Flags().BoolVar(&langGo, "golang", false, "Generate Go client (alias)")
	cmd.Flags().BoolVar(&langTS, "ts", false, "Generate TypeScript types")
	cmd.Flags().BoolVar(&langTS, "typescript", false, "Generate TypeScript types (alias)")
	cmd.Flags().BoolVar(&langPy, "py", false, "Generate Python client")
	cmd.Flags().BoolVar(&langPy, "python", false, "Generate Python client (alias)")
	cmd.Flags().BoolVar(&langJava, "java", false, "Generate Java data classes")
	cmd.Flags().BoolVar(&langKt, "kotlin", false, "Generate Kotlin data classes")
	cmd.Flags().BoolVar(&langKt, "kt", false, "Generate Kotlin data classes (alias)")
	return cmd
}

// SCHEMA -------------------------------------------------------------------
func newSchemaCmd(cfg *cfgOptions) *cobra.Command {
	var schemaPath string
	var tablesCSV string
	var publish bool
	var getOutPath string
	var getTablesCSV string
	var printOnly bool

	root := &cobra.Command{
		Use:   "schema",
		Short: "Schema operations (get/validate/diff/publish)",
		Args:  cobra.MaximumNArgs(1), // optional file path when using default get behavior
		RunE: func(cmd *cobra.Command, args []string) error {
			return runSchemaGet(cmd, cfg, getOutPath, getTablesCSV, printOnly, args)
		},
	}
	root.Flags().StringVar(&getOutPath, "out", "", "Output file path (default ./onyx.schema.json)")
	root.Flags().StringVar(&getTablesCSV, "tables", "", "Comma-separated tables to fetch (prints to stdout)")
	root.Flags().BoolVar(&printOnly, "print", false, "Print schema to stdout instead of writing file")

	// get
	get := &cobra.Command{
		Use:   "get [file]",
		Short: "Fetch latest schema from the API",
		Args:  cobra.MaximumNArgs(1),
		RunE: func(cmd *cobra.Command, args []string) error {
			return runSchemaGet(cmd, cfg, getOutPath, getTablesCSV, printOnly, args)
		},
	}
	get.Flags().StringVar(&getOutPath, "out", "", "Output file path (default ./onyx.schema.json)")
	get.Flags().StringVar(&getTablesCSV, "tables", "", "Comma-separated tables to fetch (prints to stdout)")
	get.Flags().BoolVar(&printOnly, "print", false, "Print schema to stdout instead of writing file")

	// validate
	validate := &cobra.Command{
		Use:   "validate [file]",
		Short: "Validate local schema against the API",
		Args:  cobra.MaximumNArgs(1),
		RunE: func(cmd *cobra.Command, args []string) error {
			schemaFile := pickSchemaPath(schemaPath, args)
			_, filePath, rawSchema, err := loadLocalSchema(schemaFile)
			if err != nil {
				return err
			}
			rc, err := resolveCfgOrGuide(cfg)
			if err != nil {
				return err
			}
			client := api.NewClient(rc.BaseURL.Value, rc.DatabaseID.Value, rc.APIKey.Value, rc.APISecret.Value)
			apiReady, err := normalizeSchemaForAPI(rawSchema)
			if err != nil {
				return fmt.Errorf("sanitize schema: %w", err)
			}
			res, err := client.ValidateSchemaRaw(apiReady)
			if err != nil {
				return err
			}
			fmt.Fprintf(cmd.OutOrStdout(), "valid: %t (source: %s)\n", boolValue(res.Valid), filePath)
			if len(res.Errors) > 0 {
				for _, e := range res.Errors {
					fmt.Fprintf(cmd.OutOrStdout(), "- %s\n", strings.TrimSpace(e.Message))
				}
			}
			return nil
		},
	}
	validate.Flags().StringVar(&schemaPath, "schema", config.DefaultSchemaPath, "Local schema file to validate")

	// diff
	diff := &cobra.Command{
		Use:   "diff [file]",
		Short: "Diff API schema vs local schema",
		Args:  cobra.MaximumNArgs(1),
		RunE: func(cmd *cobra.Command, args []string) error {
			schemaFile := pickSchemaPath(schemaPath, args)
			localReq, filePath, _, err := loadLocalSchema(schemaFile)
			if err != nil {
				return err
			}
			rc, err := resolveCfgOrGuide(cfg)
			if err != nil {
				return err
			}
			client := api.NewClient(rc.BaseURL.Value, rc.DatabaseID.Value, rc.APIKey.Value, rc.APISecret.Value)
			var tables []string
			if strings.TrimSpace(tablesCSV) != "" {
				tables = strings.Split(tablesCSV, ",")
			}
			apiSchema, err := client.GetSchema(tables)
			if err != nil {
				return err
			}
			diff := schema.ComputeSchemaDiff(*apiSchema, localReq)
			fmt.Fprint(cmd.OutOrStdout(), schema.FormatSchemaDiff(diff, filePath))
			return nil
		},
	}
	diff.Flags().StringVar(&schemaPath, "schema", config.DefaultSchemaPath, "Local schema file to compare")
	diff.Flags().StringVar(&tablesCSV, "tables", "", "Comma-separated tables to fetch from API")

	// publish (optional)
	publishCmd := &cobra.Command{
		Use:   "publish [file]",
		Short: "Publish local schema to API",
		Args:  cobra.MaximumNArgs(1),
		RunE: func(cmd *cobra.Command, args []string) error {
			schemaFile := pickSchemaPath(schemaPath, args)
			_, _, rawSchema, err := loadLocalSchema(schemaFile)
			if err != nil {
				return err
			}
			rc, err := resolveCfgOrGuide(cfg)
			if err != nil {
				return err
			}
			client := api.NewClient(rc.BaseURL.Value, rc.DatabaseID.Value, rc.APIKey.Value, rc.APISecret.Value)
			apiReady, err := normalizeSchemaForAPI(rawSchema)
			if err != nil {
				return fmt.Errorf("sanitize schema: %w", err)
			}
			rev, err := client.UpdateSchemaRaw(apiReady, publish)
			if err != nil {
				return err
			}
			if rev == nil || rev.Meta == nil || rev.Meta.RevisionID == "" || rev.Meta.PublishedAt == "" {
				warnMissingMeta(cmd, "publish", rc)
			}

			revID := "unknown"
			publishedAt := "unknown"
			if rev != nil && rev.Meta != nil {
				if rev.Meta.RevisionID != "" {
					revID = rev.Meta.RevisionID
				}
				if rev.Meta.PublishedAt != "" {
					publishedAt = rev.Meta.PublishedAt
				}
			}

			fmt.Fprintf(cmd.OutOrStdout(), "Published revision %s at %s\n", revID, publishedAt)
			return nil
		},
	}
	publishCmd.Flags().StringVar(&schemaPath, "schema", config.DefaultSchemaPath, "Local schema file to publish")
	publishCmd.Flags().BoolVar(&publish, "publish", true, "Whether to publish immediately")

	root.AddCommand(get, validate, diff, publishCmd)
	return root
}

func runSchemaGet(cmd *cobra.Command, cfg *cfgOptions, outPath, tablesCSV string, printOnly bool, args []string) error {
	rc, err := resolveCfgOrGuide(cfg)
	if err != nil {
		return err
	}
	client := api.NewClient(rc.BaseURL.Value, rc.DatabaseID.Value, rc.APIKey.Value, rc.APISecret.Value)

	var tables []string
	if strings.TrimSpace(tablesCSV) != "" {
		tables = strings.Split(tablesCSV, ",")
	}
	raw, rev, err := client.GetSchemaRaw(tables)
	if err != nil {
		return err
	}
	if rev == nil || rev.Meta == nil || rev.Meta.RevisionID == "" || rev.Meta.PublishedAt == "" {
		warnMissingMeta(cmd, "get", rc)
	}

	data := raw
	if len(bytes.TrimSpace(data)) > 0 {
		if sanitized, err := sanitizeSchemaJSON(data); err == nil {
			data = sanitized
		} else {
			return fmt.Errorf("sanitize schema: %w", err)
		}
	} else if rev != nil {
		pretty, err := json.MarshalIndent(rev, "", "  ")
		if err != nil {
			return fmt.Errorf("encode schema: %w", err)
		}
		data = pretty
	}

	// Pretty-print while preserving unknown fields by indenting the raw JSON.
	if len(bytes.TrimSpace(data)) > 0 {
		var buf bytes.Buffer
		if err := json.Indent(&buf, data, "", "  "); err == nil {
			data = buf.Bytes()
		}
	}
	data = append(data, '\n')

	target := outPath
	if target == "" && len(args) > 0 {
		target = args[0]
	}
	if target == "" {
		target = config.DefaultSchemaPath
	}

	// Print to stdout when requested or when fetching specific tables (parity with TS CLI).
	if printOnly || len(tables) > 0 {
		fmt.Fprint(cmd.OutOrStdout(), string(data))
		return nil
	}

	dir := filepath.Dir(target)
	if dir != "" && dir != "." {
		if err := os.MkdirAll(dir, 0o755); err != nil {
			return fmt.Errorf("create directory %s: %w", dir, err)
		}
	}
	if err := os.WriteFile(target, data, 0o644); err != nil {
		return fmt.Errorf("write schema %s: %w", target, err)
	}
	fmt.Fprintf(cmd.OutOrStdout(), "Wrote schema to %s\n", target)
	return nil
}

func loadLocalSchema(path string) (schema.SchemaUpsertRequest, string, []byte, error) {
	data, err := os.ReadFile(path)
	if err != nil {
		return schema.SchemaUpsertRequest{}, path, nil, fmt.Errorf("read schema %s: %w", path, err)
	}
	apiReady, err := normalizeSchemaForAPI(data)
	if err != nil {
		return schema.SchemaUpsertRequest{}, path, nil, err
	}
	var req schema.SchemaUpsertRequest
	if err := json.Unmarshal(apiReady, &req); err != nil {
		return schema.SchemaUpsertRequest{}, path, nil, fmt.Errorf("parse schema %s: %w", path, err)
	}
	return req, path, apiReady, nil
}

// pickSchemaPath chooses the schema path from a flag or optional positional arg.
// Positional arg wins, then flag, then default.
func pickSchemaPath(flagPath string, args []string) string {
	if len(args) > 0 && strings.TrimSpace(args[0]) != "" {
		return args[0]
	}
	if flagPath != "" {
		return flagPath
	}
	return config.DefaultSchemaPath
}

func warnMissingMeta(cmd *cobra.Command, action string, rc config.ResolvedConfig) {
	// Previously emitted warnings when metadata was absent. Now intentionally silent.
}

// sanitizeSchemaJSON removes noisy fields (currently entityText) while preserving unknowns.
func sanitizeSchemaJSON(raw []byte) ([]byte, error) {
	if len(bytes.TrimSpace(raw)) == 0 {
		return raw, nil
	}
	var v any
	if err := json.Unmarshal(raw, &v); err != nil {
		return nil, fmt.Errorf("decode schema json: %w", err)
	}
	stripEntityText(v)
	ensureTablesKey(v)
	out, err := json.Marshal(v)
	if err != nil {
		return nil, fmt.Errorf("encode schema json: %w", err)
	}
	return out, nil
}

func stripEntityText(v any) {
	switch t := v.(type) {
	case map[string]any:
		delete(t, "entityText")
		for _, val := range t {
			stripEntityText(val)
		}
	case []any:
		for _, elem := range t {
			stripEntityText(elem)
		}
	}
}

// normalizeSchemaForAPI ensures payload uses tables (and entities for compatibility) and strips entityText.
func normalizeSchemaForAPI(raw []byte) ([]byte, error) {
	if len(bytes.TrimSpace(raw)) == 0 {
		return raw, nil
	}
	var v any
	if err := json.Unmarshal(raw, &v); err != nil {
		return nil, fmt.Errorf("decode schema json: %w", err)
	}
	stripEntityText(v)
	ensureTablesKey(v)
	ensureEntitiesFromTables(v)
	out, err := json.Marshal(v)
	if err != nil {
		return nil, fmt.Errorf("encode schema json: %w", err)
	}
	return out, nil
}

func ensureTablesKey(v any) {
	if m, ok := v.(map[string]any); ok {
		if _, hasTables := m["tables"]; !hasTables {
			if ents, hasEntities := m["entities"]; hasEntities {
				m["tables"] = ents
			}
		}
		for _, val := range m {
			ensureTablesKey(val)
		}
	} else if arr, ok := v.([]any); ok {
		for _, elem := range arr {
			ensureTablesKey(elem)
		}
	}
}

func ensureEntitiesFromTables(v any) {
	if m, ok := v.(map[string]any); ok {
		if _, hasEntities := m["entities"]; !hasEntities {
			if tables, hasTables := m["tables"]; hasTables {
				m["entities"] = tables
			}
		}
		for _, val := range m {
			ensureEntitiesFromTables(val)
		}
	} else if arr, ok := v.([]any); ok {
		for _, elem := range arr {
			ensureEntitiesFromTables(elem)
		}
	}
}

func boolValue(ptr *bool) bool {
	if ptr == nil {
		return false
	}
	return *ptr
}

// VERSION ------------------------------------------------------------------
func newVersionCmd() *cobra.Command {
	return &cobra.Command{
		Use:   "version",
		Short: "Show onyx CLI version",
		RunE: func(cmd *cobra.Command, args []string) error {
			fmt.Fprintf(cmd.OutOrStdout(), "onyx version %s (commit %s, built %s)\n", onyxver.Version, onyxver.Commit, onyxver.Date)
			return nil
		},
	}
}
