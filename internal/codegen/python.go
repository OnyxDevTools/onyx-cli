package codegen

import (
	"encoding/json"
	"errors"
	"fmt"
	"os"
	"path/filepath"
	"strings"
)

// RenderPython generates models.py, tables.py, schema.py, __init__.py into outDir.
func RenderPython(schemaJSON []byte, outDir string, overwrite bool) error {
	var parsed SchemaParsed
	if err := json.Unmarshal(schemaJSON, &parsed); err != nil {
		return fmt.Errorf("parse schema: %w", err)
	}
	if len(parsed.Entities) == 0 {
		return errors.New("schema has no entities")
	}

	if err := os.MkdirAll(outDir, 0o755); err != nil {
		return err
	}

	// models.py
	var models strings.Builder
	models.WriteString("import datetime\nfrom typing import Any, Optional\n\n")
	for _, ent := range parsed.Entities {
		if ent.Name == "" {
			continue
		}
		models.WriteString("class ")
		models.WriteString(ent.Name)
		models.WriteString(":\n    \"\"\"Generated model (plain Python class). Resolver/extra fields are allowed via **extra.\"\"\"\n    def __init__(self")

		ordered := OrderAttributes(ent.Identifier.Name, ent.Attributes)
		for _, attr := range ordered {
			pyType, optional := mapPyType(attr.Type, attr.IsNullable)
			if optional {
				models.WriteString(fmt.Sprintf(", %s: Optional[%s] = None", attr.Name, pyType))
			} else {
				models.WriteString(fmt.Sprintf(", %s: %s = None", attr.Name, pyType))
			}
		}
		models.WriteString(", **extra: Any):\n")
		for _, attr := range ordered {
			models.WriteString(fmt.Sprintf("        self.%s = %s\n", attr.Name, attr.Name))
		}
		models.WriteString("        # allow resolver-attached fields or extra properties\n")
		models.WriteString("        for k, v in extra.items():\n")
		models.WriteString("            setattr(self, k, v)\n\n\n")
	}

	modelsPath := filepath.Join(outDir, "models.py")
	if !overwrite {
		if _, err := os.Stat(modelsPath); err == nil {
			return fmt.Errorf("%s exists (use --overwrite)", modelsPath)
		}
	}
	if err := os.WriteFile(modelsPath, []byte(models.String()), 0o644); err != nil {
		return err
	}

	// tables.py
	var tables strings.Builder
	tables.WriteString("class tables:\n    \"\"\"Table name constants.\"\"\"\n")
	for _, ent := range parsed.Entities {
		if ent.Name == "" {
			continue
		}
		tables.WriteString("    ")
		tables.WriteString(ent.Name)
		tables.WriteString(" = \"")
		tables.WriteString(ent.Name)
		tables.WriteString("\"\n")
	}
	tables.WriteString("\n")
	tablesPath := filepath.Join(outDir, "tables.py")
	if !overwrite {
		if _, err := os.Stat(tablesPath); err == nil {
			return fmt.Errorf("%s exists (use --overwrite)", tablesPath)
		}
	}
	if err := os.WriteFile(tablesPath, []byte(tables.String()), 0o644); err != nil {
		return err
	}

	// schema.py
	var schemaBuf strings.Builder
	schemaBuf.WriteString("SCHEMA_JSON = ")
	indented, err := json.MarshalIndent(json.RawMessage(schemaJSON), "", "  ")
	if err != nil {
		return err
	}
	pySchema := string(indented)
	pySchema = strings.ReplaceAll(pySchema, "true", "True")
	pySchema = strings.ReplaceAll(pySchema, "false", "False")
	schemaBuf.WriteString(pySchema)
	schemaBuf.WriteString("\n")
	schemaPath := filepath.Join(outDir, "schema.py")
	if !overwrite {
		if _, err := os.Stat(schemaPath); err == nil {
			return fmt.Errorf("%s exists (use --overwrite)", schemaPath)
		}
	}
	if err := os.WriteFile(schemaPath, []byte(schemaBuf.String()), 0o644); err != nil {
		return err
	}

	// __init__.py
	modelNames := make([]string, 0, len(parsed.Entities))
	for _, ent := range parsed.Entities {
		if strings.TrimSpace(ent.Name) == "" {
			continue
		}
		modelNames = append(modelNames, ent.Name)
	}
	initPath := filepath.Join(outDir, "__init__.py")
	if !overwrite {
		if _, err := os.Stat(initPath); err == nil {
			return nil
		}
	}
	var initBuf strings.Builder
	initBuf.WriteString("# Generated by onyx gen\n\n")
	if len(modelNames) > 0 {
		initBuf.WriteString("from .models import ")
		initBuf.WriteString(strings.Join(modelNames, ", "))
		initBuf.WriteString("\n")
	}
	initBuf.WriteString("from .tables import tables\n")
	initBuf.WriteString("from .schema import SCHEMA_JSON\n\n")

	initBuf.WriteString("MODEL_MAP = {\n")
	for _, name := range modelNames {
		initBuf.WriteString("    tables.")
		initBuf.WriteString(name)
		initBuf.WriteString(": ")
		initBuf.WriteString(name)
		initBuf.WriteString(",\n")
	}
	initBuf.WriteString("}\n\n")
	initBuf.WriteString("SCHEMA = MODEL_MAP\n\n")
	initBuf.WriteString("__all__ = [\n")
	initBuf.WriteString("    \"tables\",\n")
	initBuf.WriteString("    \"SCHEMA_JSON\",\n")
	initBuf.WriteString("    \"MODEL_MAP\",\n")
	initBuf.WriteString("    \"SCHEMA\",\n")
	for _, name := range modelNames {
		initBuf.WriteString("    \"")
		initBuf.WriteString(name)
		initBuf.WriteString("\",\n")
	}
	initBuf.WriteString("]\n")

	if err := os.WriteFile(initPath, []byte(initBuf.String()), 0o644); err != nil {
		return err
	}

	return nil
}

func mapPyType(schemaType string, nullable bool) (string, bool) {
	t := strings.ToLower(strings.TrimSpace(schemaType))
	var base string
	switch t {
	case "string", "text", "uuid":
		base = "str"
	case "bool", "boolean":
		base = "bool"
	case "int", "integer", "long", "short", "byte":
		base = "int"
	case "float", "double", "decimal", "number":
		base = "float"
	case "date", "datetime", "timestamp", "timestamptz":
		base = "datetime.datetime"
	case "json", "object", "record", "map", "embeddedobject":
		base = "dict"
	default:
		base = "Any"
	}
	optional := nullable
	return base, optional
}
