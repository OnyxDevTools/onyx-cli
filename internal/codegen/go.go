package codegen

import (
	"bytes"
	"encoding/json"
	"fmt"
	"os"
	"path/filepath"
	"strings"
	"time"
	"unicode"
)

type Field struct {
	Name       string
	Type       string
	IsNullable bool
}

type Table struct {
	Name      string
	Fields    []Field
	Resolvers []string
}

// RenderGoCommon generates common.go with helpers, tables map, resolvers map, DB wrapper.
func RenderGoCommon(schemaJSON []byte, outDir, pkg string, overwrite bool) error {
	tables, resolvers, err := parseTables(schemaJSON)
	if err != nil {
		return err
	}
	if err := os.MkdirAll(outDir, 0o755); err != nil {
		return err
	}
	target := filepath.Join(outDir, "common.go")
	if !overwrite {
		if _, err := os.Stat(target); err == nil {
			return fmt.Errorf("%s exists (use --overwrite)", target)
		}
	}

	var buf bytes.Buffer
	now := time.Now().UTC().Format(time.RFC3339)
	buf.WriteString("// Code generated by onyx gen --go; DO NOT EDIT.\n")
	buf.WriteString("// Generated at: " + now + "\n\n")
	buf.WriteString("package " + pkg + "\n\n")
	buf.WriteString("import (\n")
	buf.WriteString("\t\"context\"\n")
	buf.WriteString("\t\"encoding/json\"\n")
	buf.WriteString("\t\"fmt\"\n")
	buf.WriteString("\t\"time\"\n\n")
	buf.WriteString("\t\"github.com/OnyxDevTools/onyx-database-go/onyx\"\n")
	buf.WriteString(")\n\n")

	buf.WriteString("// QueryHook allows callers to observe query execution for logging, metrics, or tracing.\n")
	buf.WriteString("// The returned context from BeforeQuery will be used for the operation and passed to AfterQuery.\n")
	buf.WriteString("type QueryHook interface {\n")
	buf.WriteString("\tBeforeQuery(ctx context.Context, operation, table string) context.Context\n")
	buf.WriteString("\tAfterQuery(ctx context.Context, operation, table string, duration time.Duration, err error)\n")
	buf.WriteString("}\n\n")

	buf.WriteString("func withContextAndHook(ctx context.Context, timeout time.Duration, hook QueryHook, operation, table string) (context.Context, func(error)) {\n")
	buf.WriteString("\tvar cancel context.CancelFunc\n")
	buf.WriteString("\tif timeout > 0 {\n\t\tctx, cancel = context.WithTimeout(ctx, timeout)\n\t}\n")
	buf.WriteString("\tstart := time.Now()\n")
	buf.WriteString("\tif hook != nil {\n\t\tctx = hook.BeforeQuery(ctx, operation, table)\n\t}\n")
	buf.WriteString("\treturn ctx, func(err error) {\n")
	buf.WriteString("\t\tif hook != nil { hook.AfterQuery(ctx, operation, table, time.Since(start), err) }\n")
	buf.WriteString("\t\tif cancel != nil { cancel() }\n")
	buf.WriteString("\t}\n}\n\n")

	buf.WriteString("func Eq(field string, value any) onyx.Condition { return onyx.Eq(field, value) }\n")
	buf.WriteString("func Neq(field string, value any) onyx.Condition { return onyx.Neq(field, value) }\n")
	buf.WriteString("func In(field string, values []any) onyx.Condition { return onyx.In(field, values) }\n")
	buf.WriteString("func NotIn(field string, values []any) onyx.Condition { return onyx.NotIn(field, values) }\n")
	buf.WriteString("func Between(field string, from, to any) onyx.Condition { return onyx.Between(field, from, to) }\n")
	buf.WriteString("func Gt(field string, value any) onyx.Condition { return onyx.Gt(field, value) }\n")
	buf.WriteString("func Gte(field string, value any) onyx.Condition { return onyx.Gte(field, value) }\n")
	buf.WriteString("func Lt(field string, value any) onyx.Condition { return onyx.Lt(field, value) }\n")
	buf.WriteString("func Lte(field string, value any) onyx.Condition { return onyx.Lte(field, value) }\n")
	buf.WriteString("func Like(field string, pattern any) onyx.Condition { return onyx.Like(field, pattern) }\n")
	buf.WriteString("func Contains(field string, value any) onyx.Condition { return onyx.Contains(field, value) }\n")
	buf.WriteString("func StartsWith(field string, value any) onyx.Condition { return onyx.StartsWith(field, value) }\n")
	buf.WriteString("func IsNull(field string) onyx.Condition { return onyx.IsNull(field) }\n")
	buf.WriteString("func NotNull(field string) onyx.Condition { return onyx.NotNull(field) }\n")
	buf.WriteString("func Within(field string, query onyx.Query) onyx.Condition { return onyx.Within(field, query) }\n")
	buf.WriteString("func NotWithin(field string, query onyx.Query) onyx.Condition { return onyx.NotWithin(field, query) }\n")
	buf.WriteString("func Asc(field string) onyx.Sort { return onyx.Asc(field) }\n")
	buf.WriteString("func Desc(field string) onyx.Sort { return onyx.Desc(field) }\n")
	buf.WriteString("func Cascade(spec string) onyx.CascadeSpec { return onyx.Cascade(spec) }\n")
	buf.WriteString("func NewCascadeBuilder() onyx.CascadeBuilder { return onyx.NewCascadeBuilder() }\n\n")

	buf.WriteString("type Condition = onyx.Condition\n")
	buf.WriteString("type Sort = onyx.Sort\n")
	buf.WriteString("type Query = onyx.Query\n")
	buf.WriteString("type Schema = onyx.Schema\n")
	buf.WriteString("type Table = onyx.Table\n")
	buf.WriteString("type Field = onyx.Field\n")
	buf.WriteString("type Resolver = onyx.Resolver\n")
	buf.WriteString("type OnyxDocument = onyx.OnyxDocument\n")
	buf.WriteString("type OnyxSecret = onyx.OnyxSecret\n\n")

	buf.WriteString("var Tables = struct {\n")
	for _, t := range tables {
		fmt.Fprintf(&buf, "\t%s string\n", exportName(t.Name))
	}
	buf.WriteString("}{\n")
	for _, t := range tables {
		fmt.Fprintf(&buf, "\t%s: \"%s\",\n", exportName(t.Name), t.Name)
	}
	buf.WriteString("}\n\n")

	if len(resolvers) > 0 {
		buf.WriteString("var Resolvers = map[string][]string{\n")
		for table, rs := range resolvers {
			buf.WriteString(fmt.Sprintf("\t\"%s\": {", table))
			for i, r := range rs {
				if i > 0 {
					buf.WriteString(", ")
				}
				buf.WriteString(fmt.Sprintf("\"%s\"", r))
			}
			buf.WriteString("},\n")
		}
		buf.WriteString("}\n\n")
	}

	buf.WriteString("// DB exposes typed table clients backed by the underlying Onyx core client.\n")
	buf.WriteString("type DB struct { core onyx.Client }\n\n")
	buf.WriteString("type Config = onyx.Config\n\n")
	buf.WriteString("func New(ctx context.Context, cfg Config) (DB, error) {\n")
	buf.WriteString("\tcore, err := onyx.Init(ctx, cfg)\n")
	buf.WriteString("\tif err != nil { return DB{}, err }\n")
	buf.WriteString("\treturn DB{core: core}, nil\n}\n\n")

	buf.WriteString("func Wrap(core onyx.Client) DB { return DB{core: core} }\n\n")
	buf.WriteString("func (c DB) Core() onyx.Client { return c.core }\n\n")

	buf.WriteString("func decodeSaved(saved map[string]any, out any) error {\n\tb, err := json.Marshal(saved)\n\tif err != nil { return err }\n\treturn json.Unmarshal(b, out)\n}\n\n")
	buf.WriteString("func decodeList(items []map[string]any, out any) error {\n\tb, err := json.Marshal(items)\n\tif err != nil { return err }\n\treturn json.Unmarshal(b, out)\n}\n\n")

	buf.WriteString("func toAnyStrings(values []string) []any {\n\tout := make([]any, 0, len(values))\n\tfor _, v := range values { out = append(out, v) }\n\treturn out\n}\n\n")

	buf.WriteString("func parseCount(v any) (int, error) {\n\tswitch n := v.(type) {\n\tcase int:\n\t\treturn n, nil\n\tcase int64:\n\t\treturn int(n), nil\n\tcase float64:\n\t\treturn int(n), nil\n\tcase json.Number:\n\t\tparsed, err := n.Int64(); if err != nil { return 0, err }; return int(parsed), nil\n\tdefault:\n\t\treturn 0, fmt.Errorf(\"cannot parse count from %T\", v)\n\t}\n}\n\n")

	buf.WriteString("type DocumentsClient struct { core onyx.OnyxDocumentsClient }\n\n")
	buf.WriteString("func (c DB) Documents() DocumentsClient { return DocumentsClient{core: c.core.Documents()} }\n\n")
	buf.WriteString("func (d DocumentsClient) List(ctx context.Context) ([]onyx.OnyxDocument, error) { return d.core.List(ctx) }\n")
	buf.WriteString("func (d DocumentsClient) Get(ctx context.Context, id string) (onyx.OnyxDocument, error) { return d.core.Get(ctx, id) }\n")
	buf.WriteString("func (d DocumentsClient) Save(ctx context.Context, doc onyx.OnyxDocument) (onyx.OnyxDocument, error) { return d.core.Save(ctx, doc) }\n")
	buf.WriteString("func (d DocumentsClient) Delete(ctx context.Context, id string) error { return d.core.Delete(ctx, id) }\n\n")

	buf.WriteString("type OnyxSecretsClient struct { core onyx.Client }\n\n")
	buf.WriteString("func (c DB) OnyxSecrets() OnyxSecretsClient { return OnyxSecretsClient{core: c.core} }\n")
	buf.WriteString("func (c DB) OnyxSecret() OnyxSecretsClient  { return c.OnyxSecrets() }\n\n")
	buf.WriteString("func (s OnyxSecretsClient) List(ctx context.Context) ([]onyx.OnyxSecret, error) { return s.core.ListSecrets(ctx) }\n")
	buf.WriteString("func (s OnyxSecretsClient) Get(ctx context.Context, key string) (onyx.OnyxSecret, error) { return s.core.GetSecret(ctx, key) }\n")
	buf.WriteString("func (s OnyxSecretsClient) Set(ctx context.Context, secret onyx.OnyxSecret) (onyx.OnyxSecret, error) { return s.core.PutSecret(ctx, secret) }\n")
	buf.WriteString("func (s OnyxSecretsClient) Delete(ctx context.Context, key string) error { return s.core.DeleteSecret(ctx, key) }\n")

	return os.WriteFile(target, buf.Bytes(), 0o644)
}

// RenderGoTables emits per-table files (typed models, updates, clients, paging).
func RenderGoTables(schemaJSON []byte, outDir, pkg string, overwrite bool) error {
	tables, _, err := parseTables(schemaJSON)
	if err != nil {
		return err
	}
	if err := os.MkdirAll(outDir, 0o755); err != nil {
		return err
	}
	for _, t := range tables {
		file := filepath.Join(outDir, strings.ToLower(t.Name)+".go")
		if !overwrite {
			if _, err := os.Stat(file); err == nil {
				return fmt.Errorf("%s exists (use --overwrite)", file)
			}
		}
		content := renderTable(t, pkg)
		if err := os.WriteFile(file, []byte(content), 0o644); err != nil {
			return err
		}
	}
	return nil
}

func parseTables(schemaJSON []byte) ([]Table, map[string][]string, error) {
	var parsedEntities SchemaParsed
	if err := json.Unmarshal(schemaJSON, &parsedEntities); err != nil {
		return nil, nil, fmt.Errorf("parse schema: %w", err)
	}

	tables := make([]Table, 0)
	resolvers := make(map[string][]string)

	// Canonical path: tables-based schema.
	var tablesShape struct {
		Tables []struct {
			Name   string `json:"name"`
			Fields []struct {
				Name       string `json:"name"`
				Type       string `json:"type"`
				PrimaryKey bool   `json:"primaryKey"`
				IsNullable *bool  `json:"isNullable"`
			} `json:"fields"`
			Resolvers []struct {
				Name string `json:"name"`
			} `json:"resolvers"`
		} `json:"tables"`
	}
	if err := json.Unmarshal(schemaJSON, &tablesShape); err != nil {
		return nil, nil, fmt.Errorf("parse schema: %w", err)
	}
	for _, t := range tablesShape.Tables {
		if strings.TrimSpace(t.Name) == "" {
			continue
		}
		tbl := Table{Name: t.Name}
		for _, f := range t.Fields {
			nullable := true
			if f.PrimaryKey {
				nullable = false
			} else if f.IsNullable != nil {
				nullable = *f.IsNullable
			}
			tbl.Fields = append(tbl.Fields, Field{
				Name:       f.Name,
				Type:       f.Type,
				IsNullable: nullable,
			})
		}
		for _, r := range t.Resolvers {
			if r.Name != "" {
				tbl.Resolvers = append(tbl.Resolvers, r.Name)
			}
		}
		if len(tbl.Resolvers) > 0 {
			resolvers[tbl.Name] = append(resolvers[tbl.Name], tbl.Resolvers...)
		}
		tables = append(tables, tbl)
	}

	// Fallback: entities-based schema.
	if len(tables) == 0 {
		for _, e := range parsedEntities.Entities {
			if e.Name == "" {
				continue
			}
			tbl := Table{Name: e.Name}
			for _, a := range e.Attributes {
				tbl.Fields = append(tbl.Fields, Field{Name: a.Name, Type: a.Type, IsNullable: a.IsNullable})
			}
			for _, r := range e.Resolvers {
				if r.Name != "" {
					tbl.Resolvers = append(tbl.Resolvers, r.Name)
				}
			}
			if len(tbl.Resolvers) > 0 {
				resolvers[tbl.Name] = append(resolvers[tbl.Name], tbl.Resolvers...)
			}
			tables = append(tables, tbl)
		}
	}

	if len(tables) == 0 {
		return nil, nil, fmt.Errorf("schema has no tables or entities")
	}
	return tables, resolvers, nil
}

func renderTable(table Table, pkg string) string {
	var buf bytes.Buffer
	now := time.Now().UTC().Format(time.RFC3339)
	typeName := exportName(table.Name)
	pageName := typeName + "Page"
	pageMapName := typeName + "MapPage"
	plural := typeName + "s"
	resourceName := plural + "Client"
	mapResource := plural + "MapClient"
	pageIter := plural + "PageIterator"
	pageMapIter := plural + "MapPageIterator"
	repo := typeName + "Repository"
	updates := typeName + "Updates"
	typeLabel := strings.ToLower(typeName)
	hasEmail := hasField(table, "email")
	hasActive := hasField(table, "isActive")

	buf.WriteString("// Code generated by onyx gen --go; DO NOT EDIT.\n")
	buf.WriteString("// Generated at: " + now + "\n\n")
	buf.WriteString("package " + pkg + "\n\n")
	buf.WriteString("import (\n")
	buf.WriteString("\t\"context\"\n")
	buf.WriteString("\t\"fmt\"\n")
	buf.WriteString("\t\"time\"\n\n")
	buf.WriteString("\t\"github.com/OnyxDevTools/onyx-database-go/onyx\"\n")
	buf.WriteString(")\n\n")

	// model struct
	buf.WriteString("type " + typeName + " struct {\n")
	ordered := orderFields(table)
	for _, f := range ordered {
		goType := mapGoType(f.Type, f.IsNullable)
		buf.WriteString("\t" + exportName(f.Name) + " " + goType + " `json:\"" + f.Name + ",omitempty\"`\n")
	}
	for _, r := range table.Resolvers {
		buf.WriteString("\t" + exportName(r) + " any `json:\"" + r + ",omitempty\"`\n")
	}
	buf.WriteString("}\n\n")

	// updates
	buf.WriteString("// " + updates + " provides typed setters for update operations on " + typeName + ".\n")
	buf.WriteString("type " + updates + " struct { values map[string]any }\n\n")
	buf.WriteString("func New" + updates + "() *" + updates + " { return &" + updates + "{values: make(map[string]any)} }\n\n")
	for _, f := range ordered {
		goType := mapGoType(f.Type, f.IsNullable)
		buf.WriteString("func (u *" + updates + ") Set" + exportName(f.Name) + "(v " + goType + ") *" + updates + " {\n")
		buf.WriteString("\tif u.values == nil { u.values = make(map[string]any) }\n")
		buf.WriteString("\tu.values[\"" + f.Name + "\"] = v\n\treturn u\n}\n\n")
	}
	buf.WriteString("func (u *" + updates + ") valuesMap() map[string]any { return u.values }\n\n")

	buf.WriteString("type " + pageName + " struct {\n\tItems []" + typeName + " `json:\"items\"`\n\tNextCursor string `json:\"nextCursor,omitempty\"`\n}\n\n")
	buf.WriteString("type " + pageMapName + " struct {\n\tItems []map[string]any `json:\"items\"`\n\tNextCursor string `json:\"nextCursor,omitempty\"`\n}\n\n")

	// repo interface
	buf.WriteString("// " + repo + " captures the full set of " + resourceName + " operations for easy mocking in tests.\n")
	buf.WriteString("type " + repo + " interface {\n")
	buf.WriteString("\tWhere(cond onyx.Condition) " + resourceName + "\n")
	buf.WriteString("\tAnd(cond onyx.Condition) " + resourceName + "\n")
	buf.WriteString("\tOr(cond onyx.Condition) " + resourceName + "\n")
	buf.WriteString("\tResolve(resolvers ...string) " + resourceName + "\n")
	buf.WriteString("\tOrderBy(field string, asc bool) " + resourceName + "\n")
	buf.WriteString("\tLimit(n int) " + resourceName + "\n")
	buf.WriteString("\tSetUpdates(updates map[string]any) " + resourceName + "\n")
	buf.WriteString("\tSet" + updates + "(updates *" + updates + ") " + resourceName + "\n")
	buf.WriteString("\tSelect(fields ...string) " + mapResource + "\n")
	buf.WriteString("\tGroupBy(fields ...string) " + mapResource + "\n")
	buf.WriteString("\tAsMaps() " + mapResource + "\n")
	buf.WriteString("\tWithTimeout(d time.Duration) " + resourceName + "\n")
	buf.WriteString("\tWithDefaultTimeout() " + resourceName + "\n")
	buf.WriteString("\tWithShortTimeout() " + resourceName + "\n")
	buf.WriteString("\tWithLongTimeout() " + resourceName + "\n")
	buf.WriteString("\tWithHook(h QueryHook) " + resourceName + "\n")
	buf.WriteString("\tStream(ctx context.Context) (onyx.Iterator, error)\n")
	buf.WriteString("\tList(ctx context.Context) ([]" + typeName + ", error)\n")
	buf.WriteString("\tListMaps(ctx context.Context) ([]map[string]any, error)\n")
	buf.WriteString("\tPage(ctx context.Context, cursor string) (" + pageName + ", error)\n")
	buf.WriteString("\tPages(ctx context.Context) *" + pageIter + "\n")
	buf.WriteString("\tPageOfMaps(ctx context.Context, cursor string) (" + pageMapName + ", error)\n")
	buf.WriteString("\tUpdate(ctx context.Context) (int, error)\n")
	buf.WriteString("\tDelete(ctx context.Context) (int, error)\n")
	buf.WriteString("\tSave(ctx context.Context, item " + typeName + ", cascades ...onyx.CascadeSpec) (" + typeName + ", error)\n")
	buf.WriteString("\tSaveMany(ctx context.Context, items []" + typeName + ", cascades ...onyx.CascadeSpec) ([]" + typeName + ", error)\n")
	buf.WriteString("\tDeleteByID(ctx context.Context, id string) (int, error)\n")
	buf.WriteString("\tDeleteByIDs(ctx context.Context, ids []string) (int, error)\n")
	buf.WriteString("\tFindByID(ctx context.Context, id string) (" + typeName + ", error)\n")
	if hasEmail {
		buf.WriteString("\tFindByEmail(ctx context.Context, email string) (" + typeName + ", error)\n")
	}
	if hasActive {
		buf.WriteString("\tFindActiveUsers(ctx context.Context) ([]" + typeName + ", error)\n")
		buf.WriteString("\tCountActive(ctx context.Context) (int, error)\n")
	}
	buf.WriteString("}\n\n")

	buf.WriteString("// " + resourceName + " provides a fluent API for querying and manipulating " + typeName + " records.\n")
	buf.WriteString("type " + resourceName + " struct { core onyx.Client; q onyx.Query; timeout time.Duration; hook QueryHook }\n")
	buf.WriteString("// " + mapResource + " provides map-based query helpers returned from Select/GroupBy operations.\n")
	buf.WriteString("type " + mapResource + " struct { core onyx.Client; q onyx.Query; timeout time.Duration; hook QueryHook }\n\n")

	buf.WriteString("// " + pageIter + " iterates over paginated " + typeName + " results.\n")
	buf.WriteString("type " + pageIter + " struct { client " + resourceName + "; ctx context.Context; cursor string; started bool; page " + pageName + "; err error }\n\n")
	buf.WriteString("// " + pageMapIter + " iterates over paginated map results for " + typeName + " queries.\n")
	buf.WriteString("type " + pageMapIter + " struct { client " + mapResource + "; ctx context.Context; cursor string; started bool; page " + pageMapName + "; err error }\n\n")

	buf.WriteString("// " + plural + " returns a typed client scoped to the " + typeName + " table.\n")
	buf.WriteString("func (c DB) " + plural + "() " + resourceName + " { return " + resourceName + "{core: c.core, q: c.core.From(Tables." + typeName + ")} }\n\n")

	// client methods
	buf.WriteString("func (c " + resourceName + ") Where(cond onyx.Condition) " + resourceName + " { c.q = c.q.Where(cond); return c }\n")
	buf.WriteString("func (c " + resourceName + ") And(cond onyx.Condition) " + resourceName + " { c.q = c.q.And(cond); return c }\n")
	buf.WriteString("func (c " + resourceName + ") Or(cond onyx.Condition) " + resourceName + " { c.q = c.q.Or(cond); return c }\n")
	buf.WriteString("func (c " + resourceName + ") Resolve(resolvers ...string) " + resourceName + " { c.q = c.q.Resolve(resolvers...); return c }\n")
	buf.WriteString("func (c " + resourceName + ") OrderBy(field string, asc bool) " + resourceName + " { if asc { c.q = c.q.OrderBy(onyx.Asc(field)) } else { c.q = c.q.OrderBy(onyx.Desc(field)) }; return c }\n")
	buf.WriteString("func (c " + resourceName + ") Limit(n int) " + resourceName + " { c.q = c.q.Limit(n); return c }\n")
	buf.WriteString("func (c " + resourceName + ") SetUpdates(updates map[string]any) " + resourceName + " { c.q = c.q.SetUpdates(updates); return c }\n")
	buf.WriteString("func (c " + resourceName + ") Set" + updates + "(updates *" + updates + ") " + resourceName + " { if updates == nil { return c }; c.q = c.q.SetUpdates(updates.valuesMap()); return c }\n")
	buf.WriteString("func (c " + resourceName + ") Select(fields ...string) " + mapResource + " { c.q = c.q.Select(fields...); return " + mapResource + "{core: c.core, q: c.q, timeout: c.timeout, hook: c.hook} }\n")
	buf.WriteString("func (c " + resourceName + ") GroupBy(fields ...string) " + mapResource + " { c.q = c.q.GroupBy(fields...); return " + mapResource + "{core: c.core, q: c.q, timeout: c.timeout, hook: c.hook} }\n")
	buf.WriteString("func (c " + resourceName + ") AsMaps() " + mapResource + " { return " + mapResource + "{core: c.core, q: c.q, timeout: c.timeout, hook: c.hook} }\n")
	buf.WriteString("func (c " + resourceName + ") WithTimeout(d time.Duration) " + resourceName + " { if d <= 0 { c.timeout = 30 * time.Second; return c }; c.timeout = d; return c }\n")
	buf.WriteString("func (c " + resourceName + ") WithDefaultTimeout() " + resourceName + " { return c.WithTimeout(30 * time.Second) }\n")
	buf.WriteString("func (c " + resourceName + ") WithShortTimeout() " + resourceName + " { return c.WithTimeout(5 * time.Second) }\n")
	buf.WriteString("func (c " + resourceName + ") WithLongTimeout() " + resourceName + " { return c.WithTimeout(2 * time.Minute) }\n")
	buf.WriteString("func (c " + resourceName + ") WithHook(h QueryHook) " + resourceName + " { c.hook = h; return c }\n")

	buf.WriteString("func (c " + resourceName + ") Stream(ctx context.Context) (onyx.Iterator, error) { ctx, done := withContextAndHook(ctx, c.timeout, c.hook, \"stream\", Tables." + typeName + "); iter, err := c.q.Stream(ctx); done(err); return iter, err }\n")

	buf.WriteString("func (c " + resourceName + ") List(ctx context.Context) ([]" + typeName + ", error) { ctx, done := withContextAndHook(ctx, c.timeout, c.hook, \"list\", Tables." + typeName + "); res := onyx.List(ctx, c.q); var out []" + typeName + "; if err := res.Decode(&out); err != nil { err = fmt.Errorf(\"failed to decode " + typeName + " list: %w\", err); done(err); return nil, err }; done(nil); return out, nil }\n")
	buf.WriteString("func (c " + resourceName + ") ListMaps(ctx context.Context) ([]map[string]any, error) { ctx, done := withContextAndHook(ctx, c.timeout, c.hook, \"list_maps\", Tables." + typeName + "); res := onyx.List(ctx, c.q); var out []map[string]any; if err := res.Decode(&out); err != nil { err = fmt.Errorf(\"failed to decode " + typeName + " map list: %w\", err); done(err); return nil, err }; done(nil); return out, nil }\n")

	buf.WriteString("func (c " + resourceName + ") Page(ctx context.Context, cursor string) (" + pageName + ", error) { ctx, done := withContextAndHook(ctx, c.timeout, c.hook, \"page\", Tables." + typeName + "); res, err := c.q.Page(ctx, cursor); if err != nil { err = fmt.Errorf(\"failed to page " + typeLabel + ": %w\", err); done(err); return " + pageName + "{}, err }; if res.Items == nil { done(nil); return " + pageName + "{Items: []" + typeName + "{}, NextCursor: res.NextCursor}, nil }; var items []" + typeName + "; if err := decodeList(res.Items, &items); err != nil { err = fmt.Errorf(\"failed to decode " + typeLabel + " page: %w\", err); done(err); return " + pageName + "{}, err }; done(nil); return " + pageName + "{Items: items, NextCursor: res.NextCursor}, nil }\n")
	buf.WriteString("func (c " + resourceName + ") Pages(ctx context.Context) *" + pageIter + " { return &" + pageIter + "{client: c, ctx: ctx} }\n")
	buf.WriteString("func (c " + resourceName + ") PageOfMaps(ctx context.Context, cursor string) (" + pageMapName + ", error) { ctx, done := withContextAndHook(ctx, c.timeout, c.hook, \"page\", Tables." + typeName + "); res, err := c.q.Page(ctx, cursor); if err != nil { err = fmt.Errorf(\"failed to page " + typeLabel + " maps: %w\", err); done(err); return " + pageMapName + "{}, err }; if res.Items == nil { done(nil); return " + pageMapName + "{Items: []map[string]any{}, NextCursor: res.NextCursor}, nil }; done(nil); return " + pageMapName + "{Items: res.Items, NextCursor: res.NextCursor}, nil }\n")

	buf.WriteString("func (c " + resourceName + ") Update(ctx context.Context) (int, error) { ctx, done := withContextAndHook(ctx, c.timeout, c.hook, \"update\", Tables." + typeName + "); n, err := c.q.Update(ctx); if err != nil { err = fmt.Errorf(\"failed to update " + typeLabel + ": %w\", err); done(err); return 0, err }; done(nil); return n, nil }\n")
	buf.WriteString("func (c " + resourceName + ") Delete(ctx context.Context) (int, error) { ctx, done := withContextAndHook(ctx, c.timeout, c.hook, \"delete\", Tables." + typeName + "); n, err := c.q.Delete(ctx); if err != nil { err = fmt.Errorf(\"failed to delete " + typeLabel + ": %w\", err); done(err); return 0, err }; done(nil); return n, nil }\n")

	buf.WriteString("func (c " + resourceName + ") Save(ctx context.Context, item " + typeName + ", cascades ...onyx.CascadeSpec) (" + typeName + ", error) { var relationships []string; for i, spec := range cascades { if spec == nil { return " + typeName + "{}, fmt.Errorf(\"cascade spec at index %d is nil\", i) }; relationships = append(relationships, spec.String()) }; ctx, done := withContextAndHook(ctx, c.timeout, c.hook, \"save\", Tables." + typeName + "); saved, err := c.core.Save(ctx, Tables." + typeName + ", item, relationships); if err != nil { err = fmt.Errorf(\"failed to save " + typeLabel + ": %w\", err); done(err); return " + typeName + "{}, err }; var out " + typeName + "; if err := decodeSaved(saved, &out); err != nil { err = fmt.Errorf(\"failed to decode saved " + typeLabel + ": %w\", err); done(err); return " + typeName + "{}, err }; done(nil); return out, nil }\n")

	buf.WriteString("func (c " + resourceName + ") SaveMany(ctx context.Context, items []" + typeName + ", cascades ...onyx.CascadeSpec) ([]" + typeName + ", error) { if len(items) == 0 { return nil, nil }; var relationships []string; for i, spec := range cascades { if spec == nil { return nil, fmt.Errorf(\"cascade spec at index %d is nil\", i) }; relationships = append(relationships, spec.String()) }; out := make([]" + typeName + ", 0, len(items)); for i, item := range items { ctxOp, done := withContextAndHook(ctx, c.timeout, c.hook, \"save_many\", Tables." + typeName + "); saved, err := c.core.Save(ctxOp, Tables." + typeName + ", item, relationships); if err != nil { err = fmt.Errorf(\"failed to save " + typeLabel + " at index %d: %w\", i, err); done(err); return nil, err }; var decoded " + typeName + "; if err := decodeSaved(saved, &decoded); err != nil { err = fmt.Errorf(\"failed to decode saved " + typeLabel + " at index %d: %w\", i, err); done(err); return nil, err }; done(nil); out = append(out, decoded) }; return out, nil }\n")

	buf.WriteString("func (c " + resourceName + ") DeleteByID(ctx context.Context, id string) (int, error) { if id == \"\" { return 0, fmt.Errorf(\"id cannot be empty\") }; ctx, done := withContextAndHook(ctx, c.timeout, c.hook, \"delete_by_id\", Tables." + typeName + "); err := c.core.Delete(ctx, Tables." + typeName + ", id); if err != nil { err = fmt.Errorf(\"failed to delete " + typeLabel + " %s: %w\", id, err); done(err); return 0, err }; done(nil); return 1, nil }\n")
	buf.WriteString("func (c " + resourceName + ") DeleteByIDs(ctx context.Context, ids []string) (int, error) { if len(ids) == 0 { return 0, nil }; for i, id := range ids { if id == \"\" { return 0, fmt.Errorf(\"id at index %d is empty\", i) } }; client := c.Where(onyx.In(\"id\", toAnyStrings(ids))); ctx, done := withContextAndHook(ctx, client.timeout, client.hook, \"delete_many\", Tables." + typeName + "); n, err := client.q.Delete(ctx); if err != nil { err = fmt.Errorf(\"failed to delete " + typeLabel + " by ids: %w\", err); done(err); return 0, err }; done(nil); return n, nil }\n")

	buf.WriteString("func (c " + resourceName + ") FindByID(ctx context.Context, id string) (" + typeName + ", error) { if id == \"\" { return " + typeName + "{}, fmt.Errorf(\"id cannot be empty\") }; items, err := c.Where(onyx.Eq(\"id\", id)).Limit(1).List(ctx); if err != nil { return " + typeName + "{}, fmt.Errorf(\"failed to find " + typeLabel + " by id %s: %w\", id, err) }; if len(items) == 0 { return " + typeName + "{}, nil }; return items[0], nil }\n")
	if hasEmail {
		buf.WriteString("func (c " + resourceName + ") FindByEmail(ctx context.Context, email string) (" + typeName + ", error) { if email == \"\" { return " + typeName + "{}, fmt.Errorf(\"email cannot be empty\") }; items, err := c.Where(onyx.Eq(\"email\", email)).Limit(1).List(ctx); if err != nil { return " + typeName + "{}, fmt.Errorf(\"failed to find " + typeLabel + " by email %s: %w\", email, err) }; if len(items) == 0 { return " + typeName + "{}, nil }; return items[0], nil }\n")
	}
	if hasActive {
		buf.WriteString("func (c " + resourceName + ") FindActiveUsers(ctx context.Context) ([]" + typeName + ", error) { items, err := c.Where(onyx.Eq(\"isActive\", true)).List(ctx); if err != nil { return nil, fmt.Errorf(\"failed to list active " + typeLabel + ": %w\", err) }; return items, nil }\n")
		buf.WriteString("func (c " + resourceName + ") CountActive(ctx context.Context) (int, error) { res, err := c.Where(onyx.Eq(\"isActive\", true)).Select(\"count(id)\").List(ctx); if err != nil { return 0, fmt.Errorf(\"failed to count active " + typeLabel + ": %w\", err) }; if len(res) == 0 { return 0, nil }; count, err := parseCount(res[0][\"count(id)\"]); if err != nil { return 0, fmt.Errorf(\"failed to parse active " + typeLabel + " count: %w\", err) }; return count, nil }\n")
	}

	// map client methods
	buf.WriteString("func (c " + mapResource + ") Where(cond onyx.Condition) " + mapResource + " { c.q = c.q.Where(cond); return c }\n")
	buf.WriteString("func (c " + mapResource + ") And(cond onyx.Condition) " + mapResource + " { c.q = c.q.And(cond); return c }\n")
	buf.WriteString("func (c " + mapResource + ") Or(cond onyx.Condition) " + mapResource + " { c.q = c.q.Or(cond); return c }\n")
	buf.WriteString("func (c " + mapResource + ") Resolve(resolvers ...string) " + mapResource + " { c.q = c.q.Resolve(resolvers...); return c }\n")
	buf.WriteString("func (c " + mapResource + ") OrderBy(field string, asc bool) " + mapResource + " { if asc { c.q = c.q.OrderBy(onyx.Asc(field)) } else { c.q = c.q.OrderBy(onyx.Desc(field)) }; return c }\n")
	buf.WriteString("func (c " + mapResource + ") Limit(n int) " + mapResource + " { c.q = c.q.Limit(n); return c }\n")
	buf.WriteString("func (c " + mapResource + ") SetUpdates(updates map[string]any) " + mapResource + " { c.q = c.q.SetUpdates(updates); return c }\n")
	buf.WriteString("func (c " + mapResource + ") Select(fields ...string) " + mapResource + " { c.q = c.q.Select(fields...); return c }\n")
	buf.WriteString("func (c " + mapResource + ") GroupBy(fields ...string) " + mapResource + " { c.q = c.q.GroupBy(fields...); return c }\n")
	buf.WriteString("func (c " + mapResource + ") WithTimeout(d time.Duration) " + mapResource + " { if d <= 0 { c.timeout = 30 * time.Second; return c }; c.timeout = d; return c }\n")
	buf.WriteString("func (c " + mapResource + ") WithDefaultTimeout() " + mapResource + " { return c.WithTimeout(30 * time.Second) }\n")
	buf.WriteString("func (c " + mapResource + ") WithShortTimeout() " + mapResource + " { return c.WithTimeout(5 * time.Second) }\n")
	buf.WriteString("func (c " + mapResource + ") WithLongTimeout() " + mapResource + " { return c.WithTimeout(2 * time.Minute) }\n")
	buf.WriteString("func (c " + mapResource + ") WithHook(h QueryHook) " + mapResource + " { c.hook = h; return c }\n")
	buf.WriteString("func (c " + mapResource + ") Stream(ctx context.Context) (onyx.Iterator, error) { ctx, done := withContextAndHook(ctx, c.timeout, c.hook, \"stream\", Tables." + typeName + "); iter, err := c.q.Stream(ctx); done(err); return iter, err }\n")
	buf.WriteString("func (c " + mapResource + ") List(ctx context.Context) ([]map[string]any, error) { ctx, done := withContextAndHook(ctx, c.timeout, c.hook, \"list_maps\", Tables." + typeName + "); res := onyx.List(ctx, c.q); var out []map[string]any; if err := res.Decode(&out); err != nil { err = fmt.Errorf(\"failed to decode " + typeLabel + " map list: %w\", err); done(err); return nil, err }; done(nil); return out, nil }\n")
	buf.WriteString("func (c " + mapResource + ") Page(ctx context.Context, cursor string) (" + pageMapName + ", error) { ctx, done := withContextAndHook(ctx, c.timeout, c.hook, \"page\", Tables." + typeName + "); res, err := c.q.Page(ctx, cursor); if err != nil { err = fmt.Errorf(\"failed to page " + typeLabel + " maps: %w\", err); done(err); return " + pageMapName + "{}, err }; if res.Items == nil { done(nil); return " + pageMapName + "{Items: []map[string]any{}, NextCursor: res.NextCursor}, nil }; done(nil); return " + pageMapName + "{Items: res.Items, NextCursor: res.NextCursor}, nil }\n")
	buf.WriteString("func (c " + mapResource + ") Pages(ctx context.Context) *" + pageMapIter + " { return &" + pageMapIter + "{client: c, ctx: ctx} }\n")
	buf.WriteString("func (c " + mapResource + ") Update(ctx context.Context) (int, error) { ctx, done := withContextAndHook(ctx, c.timeout, c.hook, \"update\", Tables." + typeName + "); n, err := c.q.Update(ctx); if err != nil { err = fmt.Errorf(\"failed to update " + typeLabel + " maps: %w\", err); done(err); return 0, err }; done(nil); return n, nil }\n")
	buf.WriteString("func (c " + mapResource + ") Delete(ctx context.Context) (int, error) { ctx, done := withContextAndHook(ctx, c.timeout, c.hook, \"delete\", Tables." + typeName + "); n, err := c.q.Delete(ctx); if err != nil { err = fmt.Errorf(\"failed to delete " + typeLabel + " maps: %w\", err); done(err); return 0, err }; done(nil); return n, nil }\n")

	// iterators
	buf.WriteString("func (it *" + pageIter + ") Next() bool { if it.err != nil { return false }; if !it.started { it.started = true; it.err = it.fetch(\"\"); return it.err == nil }; if it.page.NextCursor == \"\" { return false }; it.err = it.fetch(it.page.NextCursor); return it.err == nil }\n")
	buf.WriteString("func (it *" + pageIter + ") Page() (" + pageName + ", error) { if it.err != nil { return " + pageName + "{}, it.err }; return it.page, nil }\n")
	buf.WriteString("func (it *" + pageIter + ") Err() error { return it.err }\n")
	buf.WriteString("func (it *" + pageIter + ") fetch(cursor string) error { ctx := it.ctx; client := it.client; ctx, done := withContextAndHook(ctx, client.timeout, client.hook, \"page\", Tables." + typeName + "); res, err := client.q.Page(ctx, cursor); if err != nil { err = fmt.Errorf(\"failed to page " + typeLabel + ": %w\", err); done(err); return err }; if res.Items == nil { it.page = " + pageName + "{Items: []" + typeName + "{}, NextCursor: res.NextCursor}; done(nil); return nil }; var items []" + typeName + "; if err := decodeList(res.Items, &items); err != nil { err = fmt.Errorf(\"failed to decode " + typeLabel + " page: %w\", err); done(err); return err }; it.page = " + pageName + "{Items: items, NextCursor: res.NextCursor}; done(nil); return nil }\n\n")

	buf.WriteString("func (it *" + pageMapIter + ") Next() bool { if it.err != nil { return false }; if !it.started { it.started = true; it.err = it.fetch(\"\"); return it.err == nil }; if it.page.NextCursor == \"\" { return false }; it.err = it.fetch(it.page.NextCursor); return it.err == nil }\n")
	buf.WriteString("func (it *" + pageMapIter + ") Page() (" + pageMapName + ", error) { if it.err != nil { return " + pageMapName + "{}, it.err }; return it.page, nil }\n")
	buf.WriteString("func (it *" + pageMapIter + ") Err() error { return it.err }\n")
	buf.WriteString("func (it *" + pageMapIter + ") fetch(cursor string) error { ctx := it.ctx; client := it.client; ctx, done := withContextAndHook(ctx, client.timeout, client.hook, \"page\", Tables." + typeName + "); res, err := client.q.Page(ctx, cursor); if err != nil { err = fmt.Errorf(\"failed to page " + typeLabel + " maps: %w\", err); done(err); return err }; if res.Items == nil { it.page = " + pageMapName + "{Items: []map[string]any{}, NextCursor: res.NextCursor}; done(nil); return nil }; it.page = " + pageMapName + "{Items: res.Items, NextCursor: res.NextCursor}; done(nil); return nil }\n")

	return buf.String()
}

func orderFields(table Table) []Field {
	out := make([]Field, len(table.Fields))
	copy(out, table.Fields)
	return out
}

func mapGoType(schemaType string, nullable bool) string {
	t := strings.ToLower(strings.TrimSpace(schemaType))
	var base string
	switch t {
	case "string", "text", "uuid":
		base = "*string"
	case "bool", "boolean":
		base = "*bool"
	case "int", "integer", "long", "short", "byte":
		base = "*int64"
	case "float", "double", "decimal", "number":
		base = "*float64"
	case "date", "datetime", "timestamp", "timestamptz":
		base = "*time.Time"
	case "json", "object", "record", "map", "embeddedobject":
		base = "any"
	default:
		base = "any"
	}
	return base
}

func exportName(s string) string {
	if s == "" {
		return ""
	}
	var b strings.Builder
	upperNext := true
	for _, r := range s {
		if !unicode.IsLetter(r) && !unicode.IsDigit(r) {
			upperNext = true
			continue
		}
		if upperNext {
			b.WriteRune(unicode.ToUpper(r))
			upperNext = false
		} else {
			b.WriteRune(r)
		}
	}
	out := b.String()
	if out == "" {
		return strings.Title(s)
	}
	return out
}

func hasField(table Table, name string) bool {
	for _, f := range table.Fields {
		if strings.EqualFold(f.Name, name) {
			return true
		}
	}
	return false
}
