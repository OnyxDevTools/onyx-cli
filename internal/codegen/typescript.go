package codegen

import (
	"encoding/json"
	"errors"
	"fmt"
	"strings"
)

type SchemaParsed struct {
	Tables []struct {
		Name       string `json:"name"`
		Identifier struct {
			Name string `json:"name"`
		} `json:"identifier"`
		Attributes []struct {
			Name       string `json:"name"`
			Type       string `json:"type"`
			IsNullable bool   `json:"isNullable"`
		} `json:"attributes"`
		Resolvers []struct {
			Name string `json:"name"`
		} `json:"resolvers"`
	} `json:"tables"`
	Entities []struct {
		Name       string `json:"name"`
		Identifier struct {
			Name string `json:"name"`
		} `json:"identifier"`
		Attributes []struct {
			Name       string `json:"name"`
			Type       string `json:"type"`
			IsNullable bool   `json:"isNullable"`
		} `json:"attributes"`
		Resolvers []struct {
			Name string `json:"name"`
		} `json:"resolvers"`
	} `json:"entities"`
}

// RenderTypescriptTypes emits TS interfaces, schema mapping, and tables enum.
func RenderTypescriptTypes(schemaJSON []byte, typeName string) (string, error) {
	var parsed SchemaParsed
	if err := json.Unmarshal(schemaJSON, &parsed); err != nil {
		return "", fmt.Errorf("parse schema: %w", err)
	}
	tables := parsed.Tables
	if len(tables) == 0 {
		tables = parsed.Entities
	}
	if len(tables) == 0 {
		return "", errors.New("schema has no tables")
	}

	var b strings.Builder
	b.WriteString("// AUTO-GENERATED BY onyx-gen. DO NOT EDIT.\n\n")

	for _, ent := range tables {
		if ent.Name == "" {
			continue
		}
		b.WriteString("export interface ")
		b.WriteString(ent.Name)
		b.WriteString(" {\n")

		ordered := OrderAttributes(ent.Identifier.Name, ent.Attributes)
		for _, attr := range ordered {
			tsType := mapTSType(attr.Type, attr.IsNullable)
			b.WriteString("  ")
			b.WriteString(attr.Name)
			b.WriteString("?: ")
			b.WriteString(tsType)
			b.WriteString(";\n")
		}
		b.WriteString("  [key: string]: any;\n")
		b.WriteString("}\n\n")
	}

	// Build schema mapping type and tables enum.
	b.WriteString("export type ")
	b.WriteString(typeName)
	b.WriteString(" = {\n")
	for _, ent := range tables {
		if ent.Name == "" {
			continue
		}
		b.WriteString("  ")
		b.WriteString(ent.Name)
		b.WriteString(": ")
		b.WriteString(ent.Name)
		b.WriteString(";\n")
	}
	b.WriteString("};\n\n")
	b.WriteString("export type Schema = ")
	b.WriteString(typeName)
	b.WriteString(";\n")
	b.WriteString("export const Schema = {} as ")
	b.WriteString(typeName)
	b.WriteString(";\n\n")

	b.WriteString("export enum tables {\n")
	for _, ent := range tables {
		if ent.Name == "" {
			continue
		}
		b.WriteString("  ")
		b.WriteString(ent.Name)
		b.WriteString(" = \"")
		b.WriteString(ent.Name)
		b.WriteString("\",\n")
	}
	b.WriteString("}\n")

	return b.String(), nil
}

func mapTSType(schemaType string, nullable bool) string {
	t := strings.ToLower(strings.TrimSpace(schemaType))
	var base string
	switch t {
	case "string", "text", "uuid":
		base = "string"
	case "number", "int", "integer", "float", "double", "long", "short", "byte", "decimal":
		base = "number"
	case "bool", "boolean":
		base = "boolean"
	case "date", "datetime", "timestamp", "timestamptz":
		base = "Date"
	case "json", "object", "record", "map", "embeddedobject":
		base = "any"
	default:
		base = "any"
	}
	if nullable {
		return base + " | null"
	}
	return base
}
