package codegen

import (
	"encoding/json"
	"fmt"
	"os"
	"path/filepath"
	"strings"
)

// RenderJavaTypes writes one Java class per entity (types only, no client wrapper).
// Classes are placed in outDir/<pkg path>/<Entity>.java.
func RenderJavaTypes(schemaJSON []byte, pkg string, outDir string, overwrite bool) error {
	var parsed SchemaParsed
	if err := json.Unmarshal(schemaJSON, &parsed); err != nil {
		return fmt.Errorf("parse schema: %w", err)
	}
	if len(parsed.Entities) == 0 {
		return fmt.Errorf("schema has no entities")
	}

	pkgPath := strings.ReplaceAll(strings.TrimSpace(pkg), ".", string(filepath.Separator))
	baseDir := outDir
	if baseDir == "" {
		baseDir = "."
	}
	targetDir := filepath.Join(baseDir, pkgPath)
	if err := os.MkdirAll(targetDir, 0o755); err != nil {
		return err
	}

	for _, ent := range parsed.Entities {
		if ent.Name == "" {
			continue
		}
		filename := filepath.Join(targetDir, ent.Name+".java")
		if !overwrite {
			if _, err := os.Stat(filename); err == nil {
				return fmt.Errorf("%s exists (use --overwrite)", filename)
			}
		}
		content := renderJavaClass(ent.Name, ent.Attributes, ent.Resolvers, pkg)
		if err := os.WriteFile(filename, []byte(content), 0o644); err != nil {
			return fmt.Errorf("write %s: %w", filename, err)
		}
	}
	return nil
}

func renderJavaClass(name string, attrs []struct {
	Name       string `json:"name"`
	Type       string `json:"type"`
	IsNullable bool   `json:"isNullable"`
}, resolvers []struct {
	Name string `json:"name"`
}, pkg string) string {
	var b strings.Builder
	b.WriteString("// Code generated by onyx gen --java; DO NOT EDIT.\n\n")
	if strings.TrimSpace(pkg) != "" {
		b.WriteString("package ")
		b.WriteString(pkg)
		b.WriteString(";\n\n")
	}
	importInstant := false
	for _, a := range attrs {
		if isJavaTimeType(a.Type) {
			importInstant = true
			break
		}
	}
	if importInstant {
		b.WriteString("import java.time.Instant;\n")
	}
	b.WriteString("\n")
	b.WriteString("public class ")
	b.WriteString(name)
	b.WriteString(" {\n")
	for _, a := range attrs {
		jt := mapJavaType(a.Type, a.IsNullable)
		b.WriteString("  public ")
		b.WriteString(jt)
		b.WriteString(" ")
		b.WriteString(a.Name)
		b.WriteString(";\n")
	}
	for _, r := range resolvers {
		if strings.TrimSpace(r.Name) == "" {
			continue
		}
		b.WriteString("  public Object ")
		b.WriteString(r.Name)
		b.WriteString(";\n")
	}
	b.WriteString("\n  public ")
	b.WriteString(name)
	b.WriteString("() {}\n")
	b.WriteString("}\n")
	return b.String()
}

func mapJavaType(schemaType string, nullable bool) string {
	t := strings.ToLower(strings.TrimSpace(schemaType))
	switch t {
	case "string", "text", "uuid":
		return "String"
	case "number", "int", "integer", "float", "double", "long", "short", "byte", "decimal":
		return "Double"
	case "bool", "boolean":
		return "Boolean"
	case "date", "datetime", "timestamp", "timestamptz":
		return "Instant"
	case "json", "object", "record", "map", "embeddedobject":
		return "Object"
	default:
		return "Object"
	}
}

func isJavaTimeType(schemaType string) bool {
	switch strings.ToLower(strings.TrimSpace(schemaType)) {
	case "date", "datetime", "timestamp", "timestamptz":
		return true
	default:
		return false
	}
}
